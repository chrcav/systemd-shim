From 5b7e95579fb48a869d4036f9bbb338d130000fcb Mon Sep 17 00:00:00 2001
From: Ryan Lortie <desrt@desrt.ca>
Date: Fri, 11 Jul 2014 11:38:09 -0400
Subject: [PATCH 1/3] support logind cgroup requests

Respond to the StartUnit and StartTransientUnit requests by logind
which are requests to create cgroups for the login session.
---
 src/Makefile.am     |   3 +
 src/cgmanager.c     | 160 ++++++++++++++++++++++++++++++++++++++++++++
 src/cgmanager.h     |  35 ++++++++++
 src/cgroup-unit.c   | 186 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/systemd-iface.h |   6 ++
 src/systemd-shim.c  |  21 ++++++
 src/unit.c          |  18 +++++
 src/unit.h          |   4 ++
 8 files changed, 433 insertions(+)
 create mode 100644 src/cgmanager.c
 create mode 100644 src/cgmanager.h
 create mode 100644 src/cgroup-unit.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 46e2e9d..0a7d1ff 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,9 +11,12 @@ libexec_PROGRAMS = systemd-shim
 systemd_shim_LDADD = $(gio_LIBS)
 systemd_shim_SOURCES = \
 	$(systemd_imports)	\
+	cgmanager.h		\
+	cgmanager.c		\
 	unit.h			\
 	unit.c			\
 	ntp-unit.c		\
 	power-unit.c		\
+	cgroup-unit.c		\
 	systemd-iface.h		\
 	systemd-shim.c
diff --git a/src/cgmanager.c b/src/cgmanager.c
new file mode 100644
index 0000000..30410b8
--- /dev/null
+++ b/src/cgmanager.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright © 2014 Canonical Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the licence, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Authors:
+ *   Serge Hallyn <serge.hallyn@canonical.com>
+ *   Stéphane Graber <stephane.graber@canonical.com>
+ *   Ryan Lortie <desrt@desrt.ca>
+ */
+
+#include "cgmanager.h"
+
+#include <gio/gio.h>
+
+#define CGM_DBUS_ADDRESS          "unix:path=/sys/fs/cgroup/cgmanager/sock"
+#define CGM_REQUIRED_VERSION      6
+
+static GDBusConnection *
+cgmanager_connect (GError **error)
+{
+  GDBusConnection *connection;
+  GVariant *reply;
+  GVariant *version;
+
+  connection = g_dbus_connection_new_for_address_sync (CGM_DBUS_ADDRESS,
+                                                       G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,
+                                                       NULL, NULL, error);
+
+  if (!connection)
+    return NULL;
+
+  reply = g_dbus_connection_call_sync (connection, NULL, "/org/linuxcontainers/cgmanager",
+                                       "org.freedesktop.DBus.Properties", "Get",
+                                       g_variant_new ("(ss)", "org.linuxcontainers.cgmanager0_0", "api_version"),
+                                       G_VARIANT_TYPE ("(v)"), G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+  if (!reply)
+    {
+      g_object_unref (connection);
+      return NULL;
+    }
+
+  g_variant_get (reply, "(v)", &version);
+  g_variant_unref (reply);
+
+  if (!g_variant_is_of_type (version, G_VARIANT_TYPE_INT32) || g_variant_get_int32 (version) < CGM_REQUIRED_VERSION)
+    {
+      g_set_error_literal (error, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED, "Incorrect cgmanager API version");
+      g_object_unref (connection);
+      g_variant_unref (version);
+      return NULL;
+    }
+
+  g_variant_unref (version);
+
+  return connection;
+}
+
+static void
+log_warning_on_error (GObject      *source,
+                      GAsyncResult *result,
+                      gpointer      user_data)
+{
+  GError *error = NULL;
+  GVariant *reply;
+
+  reply = g_dbus_connection_call_finish (G_DBUS_CONNECTION (source), result, &error);
+
+  if (reply)
+    g_variant_unref (reply);
+  else
+    {
+      g_warning ("cgmanager method call failed: %s.  Use G_DBUS_DEBUG=message for more info.", error->message);
+      g_error_free (error);
+    }
+}
+
+static void
+cgmanager_call (const gchar        *method_name,
+                GVariant           *parameters,
+                const GVariantType *reply_type)
+{
+  static GDBusConnection *connection;
+  static gboolean initialised;
+
+  /* Use a separate bool to prevent repeated attempts to connect to a
+   * defunct cgmanager...
+   */
+  if (!initialised)
+    {
+      GError *error = NULL;
+
+      connection = cgmanager_connect (&error);
+
+      if (!connection)
+        {
+          g_warning ("Could not connect to cgmanager: %s", error->message);
+          g_error_free (error);
+        }
+
+      initialised = TRUE;
+    }
+
+  if (!connection)
+    return;
+
+  /* Avoid round-trip delays: issue all calls at once and report errors
+   * asynchronously.  The user can enable GDBus debugging if they need
+   * more information about the exact call that failed...
+   */
+  g_dbus_connection_call (connection, NULL, "/org/linuxcontainers/cgmanager",
+                          "org.linuxcontainers.cgmanager0_0", method_name,
+                          parameters, reply_type, G_DBUS_CALL_FLAGS_NONE,
+                          -1, NULL, log_warning_on_error, NULL);
+}
+
+void
+cgmanager_create (const gchar *path,
+                  gint         uid,
+                  guint       *pids,
+                  guint        n_pids)
+{
+  guint i;
+
+  if (path[0] == '/')
+    path++;
+
+  cgmanager_call ("Create", g_variant_new ("(ss)", "all", path), G_VARIANT_TYPE ("(i)"));
+
+  if (uid != -1)
+    cgmanager_call ("Chown", g_variant_new ("(ssii)", "all", path, uid, -1), G_VARIANT_TYPE_UNIT);
+
+  for (i = 0; i < n_pids; i++)
+    cgmanager_call ("MovePid", g_variant_new ("(ssi)", "all", path, pids[i]), G_VARIANT_TYPE_UNIT);
+
+  cgmanager_call ("RemoveOnEmpty", g_variant_new ("(ss)", "all", path), G_VARIANT_TYPE_UNIT);
+}
+
+void
+cgmanager_remove (const gchar *path)
+{
+  if (path[0] == '/')
+    path++;
+
+  cgmanager_call ("Remove", g_variant_new ("(ssi)", "all", path, 1), G_VARIANT_TYPE ("(i)"));
+}
diff --git a/src/cgmanager.h b/src/cgmanager.h
new file mode 100644
index 0000000..eef704d
--- /dev/null
+++ b/src/cgmanager.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright © 2014 Canonical Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the licence, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Authors:
+ *   Ryan Lortie <desrt@desrt.ca>
+ */
+
+#ifndef _cgmanager_h_
+#define _cgmanager_h_
+
+#include <glib.h>
+
+void cgmanager_create (const gchar *path,
+                       gint         uid,
+                       guint       *pids,
+                       guint        n_pids);
+
+void cgmanager_remove (const gchar *path);
+
+#endif /* _cgmanager_h_ */
diff --git a/src/cgroup-unit.c b/src/cgroup-unit.c
new file mode 100644
index 0000000..d6f9739
--- /dev/null
+++ b/src/cgroup-unit.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright © 2014 Canonical Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the licence, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ */
+
+#include "unit.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+typedef UnitClass CGroupUnitClass;
+static GType cgroup_unit_get_type (void);
+
+typedef struct
+{
+  Unit parent_instance;
+  gchar *name;
+} CGroupUnit;
+
+G_DEFINE_TYPE (CGroupUnit, cgroup_unit, UNIT_TYPE)
+
+static gchar *
+cgroup_unit_get_path_and_uid (const gchar *slice,
+                              const gchar *scope,
+                              gint        *uid)
+{
+  GString *path;
+  gint i;
+
+  path = g_string_new (NULL);
+  for (i = 0; slice[i]; i++)
+    if (slice[i] == '-')
+      {
+        g_string_append_len (path, slice, i);
+        g_string_append (path, ".slice/");
+      }
+
+  g_string_append_len (path, slice, i);
+
+  *uid = -1;
+  if (g_str_has_prefix (slice, "user-"))
+    {
+      guint64 value;
+      gchar *end;
+
+      errno = 0;
+      value = g_ascii_strtoull (slice + 5, &end, 10);
+      if (errno == 0 && g_str_equal (end, ".slice") && value < G_MAXINT)
+        *uid = (gint) value;
+    }
+
+  if (scope)
+    {
+      g_string_append_c (path, '/');
+      g_string_append (path, scope);
+    }
+
+  return g_string_free (path, FALSE);
+}
+
+static void
+cgroup_unit_start_transient (Unit     *unit,
+                             GVariant *properties)
+{
+  CGroupUnit *cg_unit = (CGroupUnit *) unit;
+  GVariantIter iter;
+  const gchar *key;
+  GVariant *value;
+  gchar *slice;
+  GArray *pids;
+
+  if (!g_str_has_suffix (cg_unit->name, ".scope"))
+    {
+      g_warning ("%s: Can only StartTransient for scopes", cg_unit->name);
+      return;
+    }
+
+  pids = g_array_new (TRUE, FALSE, sizeof (guint));
+  slice = NULL;
+
+  g_variant_iter_init (&iter, properties);
+  while (g_variant_iter_loop (&iter, "(&sv)", &key, &value))
+    {
+      if (g_str_equal (key, "Slice") && g_variant_is_of_type (value, G_VARIANT_TYPE_STRING))
+        {
+          g_free (slice);
+          slice = g_variant_dup_string (value, NULL);
+        }
+
+      else if (g_str_equal (key, "PIDs") && g_variant_is_of_type (value, G_VARIANT_TYPE ("au")))
+        {
+          const guint *vals;
+          gsize n_vals;
+
+          vals = g_variant_get_fixed_array (value, &n_vals, sizeof (guint));
+          g_array_append_vals (pids, vals, n_vals);
+        }
+    }
+
+  if (slice && g_str_has_suffix (slice, ".slice"))
+    {
+      gchar *path;
+      gint uid;
+
+      path = cgroup_unit_get_path_and_uid (slice, cg_unit->name, &uid);
+      cgmanager_create (path, uid, (const guint *) pids->data, pids->len);
+      g_free (path);
+    }
+  else
+    g_warning ("%s: StartTransient failed: requires 'Slice' property ending with '.slice'", cg_unit->name);
+
+  g_array_free (pids, TRUE);
+}
+
+static void
+cgroup_unit_start (Unit *unit)
+{
+  CGroupUnit *cg_unit = (CGroupUnit *) unit;
+  gchar *path;
+  gint uid;
+
+  if (!g_str_has_suffix (cg_unit->name, ".slice"))
+    {
+      g_warning ("%s: Can only Start for slices", cg_unit->name);
+      return;
+    }
+
+  path = cgroup_unit_get_path_and_uid (cg_unit->name, NULL, &uid);
+  cgmanager_create (path, uid, NULL, 0);
+  g_free (path);
+}
+
+static void
+cgroup_unit_stop (Unit *unit)
+{
+  /* for now, no-op */
+}
+
+static const gchar *
+cgroup_unit_get_state (Unit *unit)
+{
+  return "static";
+}
+
+Unit *
+cgroup_unit_new (const gchar *name)
+{
+  CGroupUnit *unit;
+
+  unit = g_object_new (cgroup_unit_get_type (), NULL);
+  unit->name = g_strdup (name);
+
+  return (Unit *) unit;
+}
+
+static void
+cgroup_unit_init (CGroupUnit *unit)
+{
+}
+
+static void
+cgroup_unit_class_init (UnitClass *class)
+{
+  class->start_transient = cgroup_unit_start_transient;
+  class->start = cgroup_unit_start;
+  class->stop = cgroup_unit_stop;
+  class->get_state = cgroup_unit_get_state;
+}
diff --git a/src/systemd-iface.h b/src/systemd-iface.h
index 4d8b426..9b2a7d3 100644
--- a/src/systemd-iface.h
+++ b/src/systemd-iface.h
@@ -31,6 +31,12 @@ const gchar *systemd_iface =
      "<arg name='mode' type='s' direction='in'/>"
      "<arg name='job' type='o' direction='out'/>"
     "</method>"
+    "<method name='StartTransientUnit'>"
+     "<arg name='name' type='s' direction='in'/>"
+     "<arg name='mode' type='s' direction='in'/>"
+     "<arg name='properties' type='a(sv)' direction='in'/>"
+     "<arg name='job' type='o' direction='out'/>"
+    "</method>"
     "<method name='Reload'/>"
     "<property name='Virtualization' type='s' access='read'/>"
    "</interface>"
diff --git a/src/systemd-shim.c b/src/systemd-shim.c
index 0cd9da3..f8f74c7 100644
--- a/src/systemd-shim.c
+++ b/src/systemd-shim.c
@@ -133,6 +133,27 @@ shim_method_call (GDBusConnection       *connection,
           goto success;
         }
     }
+  else if (g_str_equal (method_name, "StartTransientUnit"))
+    {
+      Unit *unit;
+
+      unit = lookup_unit (parameters, &error);
+
+      if (unit)
+        {
+          GVariant *properties;
+
+          properties = g_variant_get_child_value (parameters, 2);
+          unit_start_transient (unit, properties);
+          g_dbus_method_invocation_return_value (invocation, g_variant_new ("(o)", "/"));
+          g_dbus_connection_emit_signal (connection, sender, "/org/freedesktop/systemd1",
+                                         "org.freedesktop.systemd1.Manager", "JobRemoved",
+                                         g_variant_new ("(uoss)", 0, "/", "", ""), NULL);
+          g_variant_unref (properties);
+          g_object_unref (unit);
+          goto success;
+      }
+  }
 
   else
     g_assert_not_reached ();
diff --git a/src/unit.c b/src/unit.c
index 2e3695d..ee27afa 100644
--- a/src/unit.c
+++ b/src/unit.c
@@ -55,6 +55,9 @@ lookup_unit (GVariant  *parameters,
   else if (g_str_equal (unit_name, "shutdown.target") || g_str_equal (unit_name, "poweroff.target"))
     unit = power_unit_new (POWER_OFF);
 
+  else if (g_str_has_suffix (unit_name, ".slice") || g_str_has_suffix (unit_name, ".scope"))
+    unit = cgroup_unit_new (unit_name);
+
   if (unit == NULL)
     g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_FILE_NOT_FOUND,
                  "Unknown unit: %s", unit_name);
@@ -79,6 +82,21 @@ unit_start (Unit *unit)
 }
 
 void
+unit_start_transient (Unit     *unit,
+                      GVariant *properties)
+{
+  g_return_if_fail (unit != NULL);
+
+  if (!UNIT_GET_CLASS (unit)->start_transient)
+    {
+      g_warning ("%s does not implement StartTransient", G_OBJECT_TYPE_NAME (unit));
+      return;
+    }
+
+  return UNIT_GET_CLASS (unit)->start_transient (unit, properties);
+}
+
+void
 unit_stop (Unit *unit)
 {
   g_return_if_fail (unit != NULL);
diff --git a/src/unit.h b/src/unit.h
index 58b4023..3ef639f 100644
--- a/src/unit.h
+++ b/src/unit.h
@@ -33,12 +33,14 @@ typedef struct
 
   const gchar * (* get_state) (Unit *unit);
   void (* start) (Unit *unit);
+  void (* start_transient) (Unit *unit, GVariant *properties);
   void (* stop) (Unit *unit);
 } UnitClass;
 
 GType unit_get_type (void);
 Unit *lookup_unit (GVariant *parameters, GError **error);
 const gchar *unit_get_state (Unit *unit);
+void unit_start_transient (Unit *unit, GVariant *properties);
 void unit_start (Unit *unit);
 void unit_stop (Unit *unit);
 
@@ -55,4 +57,6 @@ typedef enum
 
 Unit *power_unit_new (PowerAction action);
 
+Unit *cgroup_unit_new (const gchar *name);
+
 #endif /* _unit_h_ */
-- 
1.9.1

